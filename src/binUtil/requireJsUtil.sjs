
require child_process
require fs
require path
require seriousjs
require ./util as sjsUtil

_requireJsSource = path.join(__dirname, '../../lib/requirejs')

serveWebapp = (app, appPath, {<
    headers = [], shim = [], title = "My Webapp - SeriousJs", fixtures = null }) ->
  """This method sets up a GET handler at the given appPath to serve up a basic
  page that loads a RequireJS application.

  Parameters:
  app - The express app object
  appPath - The path to serve this application's page at
  options - dict, of:
    title: The title of the page
    shim: A list of files in or relative to the webapp/shim directory, these
        files are included on the page directly instead of through requireJS.
        This is used for e.g. jQuery and backbone, and other frameworks that
        must load before your code and are not necessarily RequireJS compatible.
    headers: Extra, custom headers to put into the <head> section of the page
        (other than the <script> and <link> tags generated by shim)
    fixtures: Either a static javascript object OR a function that takes (req)
        from express and returns a javascript object.  The object will be
        exposed on the page as "fixtures" and is useful for bootstrapping
        information on the page.
  """
  headers = headers[:]
  for s in shim
    prefix = "/src/shim/"
    if /^\//.test(s)
      prefix = ""
    if /\.css$/.test(s)
      headers.push '<link rel="stylesheet" href="#{ prefix }#{ s }" />'
    else
      headers.push '<script type="text/javascript" '
          + 'src="#{ prefix }#{ s + ".js" }">'
          + '</script>'
  headers.push """<script type="text/javascript">
      var fixtures = {{sjs_fixtures_object}};</script>"""
  headers.push """<script type="text/javascript"
      data-main="/src/.requirejs/loader" src="/src/.requirejs/require.js">
      </script>"""
  htmlSrc = """<!DOCTYPE html><html>
      <head><title>#{ title }</title>
        #{ headers.join('') }</head>
      <body>Loading, please wait</body></html>"""
  app.get appPath, (req, res) ->
    async
      html = htmlSrc
      if fixtures?
        fix = null
        if typeof fixtures == "function"
          await fix = fixtures(req)
        else
          fix = fixtures
        html = html.replace(/{{sjs_fixtures_object}}/, JSON.stringify(fix))

      res.send(html)


setupWebapp = async (app, express, webappPath) ->
  """This method is responsible for handling an application that uses the
  built-in support for RequireJS of SeriousJs.

  Requires a reference to express so that we use the app's version of the
  module and not seriousjs'.

  Calls callback with true if app should continue executing (not just a build),
  false if it should terminate.  If true is returned, then app is configured
  with /src pointing to the given webappPath.  Additionally creates a .requirejs
  directory within webappPath, populated with the necessary bootstrap scripts
  needed for this application to work.

  app and express are optional, for static compilation.
  """
  target = path.resolve(path.join(webappPath, '.requirejs'))
  if not fs.existsSync(target)
    fs.mkdirSync(target)

  copy = (name, {< isAbsolute = false, replace = [] }) ->
    copySource = name
    if not isAbsolute
      copySource = path.join(_requireJsSource, name)
    else
      name = path.basename(copySource)

    copyTarget = path.join(target, name)

    if fs.existsSync(copyTarget)
      fs.unlinkSync(copyTarget)

    contents = fs.readFileSync(copySource, 'utf8')
    for r in replace
      contents = contents.replace(r[0], r[1])
    fs.writeFileSync(copyTarget, contents)

  # Copy require.js into path...
  await extern _embeddedFile = seriousjs._getEmbeddedFile()
  copy(_embeddedFile, isAbsolute: true)
  copy('require.js')
  copy('css.js')
  copy('sjs.js')
  loaderOptions = {}
  if not app?
    loaderOptions.replace = [ [ /\.\/src/g, "./" ] ]
  copy('loader.js', loaderOptions)
  copy('app.build.js')

  # Now that it's set up, check for compiles and whatnot.
  if '--build' in process.argv
    await _buildApp(path.join(target, '..'))
    console.log("Build finished.")
    # Exit without calling callback or any setup.
    return false

  if app?
    # Link shim folder, which is never compiled
    app.use('/src/shim', express.static(path.join(webappPath, 'shim')))

    # Link the app to /src and run callback to start the server
    if '--built' in process.argv
      # Compiled mode
      await _buildApp(path.join(target, '..'))
      app.use('/src', express.static(path.join(webappPath, '../build.webapp')))
    else
      # Debug mode
      app.use('/src/shared', express.static(path.join(webappPath, '../shared'))
      app.use('/src', express.static(webappPath))

  # Return true to say the app can start
  return true


_buildApp = async (target) ->
  appBuildJs = path.join(target, '.requirejs/app.build.js')
  rJs = path.join(__dirname, '../../lib/requirejs/r.js')
  rJsProc = child_process.spawn(
      'node',
      [ rJs, '-o', appBuildJs ],
      cwd: target
      stdio: 'pipe'
  allStdout = []
  allStderr = []
  rJsProc.stdout.on 'data', (data) ->
    allStdout.push(data)
  rJsProc.stderr.on 'data', (data) ->
    allStderr.push(data)

  await noerror code = rJsProc.on('exit')

  if code == 0
    # Delete the old build.webapp, and put in the new one
    sjsUtil.rmDir(path.join(target, '../build.webapp'))
    fs.renameSync(path.join(target, '../build.webapp.new'),
        path.join(target, '../build.webapp'))
    # Delete every file in the new build directory except .requirejs/*
    sjsUtil.rmDirFiles(path.join(target, '../build.webapp'),
        /\.(js|sjs)$/,
        /\.requirejs\/loader\.js|\.requirejs\/require\.js$/)
  else
    throw new Error("Build failed:\n== stdout ==\n#{ allStdout.join("") }\n"
        + "== stderr ==\n#{ allStderr.join("") }")
